const child = require('child_process')
const path = require('path')
const Handler = require('./handler')
const fs = require('fs')
const EventEmitter = require('events').EventEmitter

class MCLCore extends EventEmitter {
  async launch (options) {
    try {
      this.options = { ...options }
      this.options.root = path.resolve(this.options.root)
      this.options.overrides = {
        detached: true,
        ...this.options.overrides,
        url: {
          meta: 'https://launchermeta.mojang.com',
          resource: 'https://resources.download.minecraft.net',
          mavenForge: 'http://files.minecraftforge.net/maven/',
          defaultRepoForge: 'https://libraries.minecraft.net/',
          fallbackMaven: 'https://search.maven.org/remotecontent?filepath=',
          ...this.options.overrides
            ? this.options.overrides.url
            : undefined
        },
        fw: {
          baseUrl: 'https://github.com/ZekerZhayard/ForgeWrapper/releases/download/',
          version: '1.5.5',
          sh1: '566dfd60aacffaa02884614835f1151d36f1f985',
          size: 34331,
          ...this.options.overrides
            ? this.options.overrides.fw
            : undefined
        }
      }

      this.handler = new Handler(this)

      this.printVersion()

      const java = await this.handler.checkJava(this.options.javaPath || 'java')
      if (!java.run) {
        this.emit('debug', `[MCLC]: Couldn't start Minecraft due to: ${java.message}`)
        this.emit('close', 1)
        return null
      }

      this.createRootDirectory()
      this.createGameDirectory()

      await this.extractPackage()

      if (this.options.installer) {
        // So installers that create a profile in launcher_profiles.json can run without breaking.
        const profilePath = path.join(this.options.root, 'launcher_profiles.json')
        if (!fs.existsSync(profilePath) || !JSON.parse(fs.readFileSync(profilePath)).profiles) {
          fs.writeFileSync(profilePath, JSON.stringify({ profiles: {} }, null, 4))
        }
        const code = await this.handler.runInstaller(this.options.installer)
        if (!this.options.version.custom && code === 0) {
          this.emit('debug', '[MCLC]: Installer successfully ran, but no custom version was provided')
        }
        this.emit('debug', `[MCLC]: Installer closed with code ${code}`)
      }

      const directory = this.options.overrides.directory
      this.options.directory = directory

      const versionFile = await this.handler.getVersion()
      const mcPath = this.options.overrides.minecraftJar || (this.options.version.custom
        ? path.join(this.options.root, 'versions', this.options.version.custom, `${this.options.version.custom}.jar`)
        : path.join(directory, `${this.options.version.number}.jar`))
      this.options.mcPath = mcPath
      const nativePath = await this.handler.getNatives()

      if (!fs.existsSync(mcPath)) {
        this.emit('debug', '[MCLC]: Attempting to download Minecraft version jar')
        await this.handler.getJar()
      }

      const modifyJson = await this.getModifyJson()

      const args = []

      let jvm = [
        '-XX:-UseAdaptiveSizePolicy',
        '-XX:-OmitStackTraceInFastThrow',
        '-Dfml.ignorePatchDiscrepancies=true',
        '-Dfml.ignoreInvalidMinecraftCertificates=true',
        `-Djava.library.path=${nativePath}`,
        `-Xmx${this.handler.getMemory()[0]}`,
        `-Xms${this.handler.getMemory()[1]}`
      ]
      if (this.handler.getOS() === 'osx') {
        if (parseInt(versionFile.id.split('.')[1]) > 12) jvm.push(await this.handler.getJVM())
      } //else jvm.push(await this.handler.getJVM())

      if (this.options.customArgs) jvm = jvm.concat(this.options.customArgs)
      // https://help.minecraft.net/hc/en-us/articles/4416199399693-Security-Vulnerability-in-Minecraft-Java-Edition

      Object.prototype.removeItem = function (key) {
        if (!this.hasOwnProperty(key))
           return
        if (isNaN(parseInt(key)) || !(this instanceof Array))
           delete this[key]
        else
           this.splice(key, 1)
     };

      const classes = this.options.overrides.classes || this.handler.cleanUp(await this.handler.getClasses(modifyJson))
      const classPaths = ['-cp']
      const separator = this.handler.getOS() === 'windows' ? ';' : ':'
      this.emit('debug', `[MCLC]: Using ${separator} to separate class paths`)
      // Handling launch arguments.
      const file = modifyJson || versionFile
      // So mods like fabric work.

      const StringBuilder = require("string-builder");
      const sbLibs = new StringBuilder();
  
      if(process.platform == "win32"){
          fs.readdirSync(this.options.overrides.libraryRoot).forEach(file => {
              sbLibs.append(""+path.join(this.options.overrides.libraryRoot, file+';').replace('\\', '//')+"")
          });
      }else if(process.platform == "linux"){
          fs.readdirSync(this.options.overrides.libraryRoot).forEach(file => {
              sbLibs.append(""+path.join(this.options.overrides.libraryRoot, file).replace('\\', '//')+'":')
          });
      }

      const jar = fs.existsSync(mcPath)
        ? `${mcPath}`
        : `"${path.join(directory, `${this.options.version.number}.jar`)}"${separator}`

      classPaths.push(sbLibs+`${jar}`)
      classPaths.push(this.options.overrides.classMain)

      // Forge -> Custom -> Vanilla
      const launchOptions = await this.handler.getLaunchOptions(modifyJson)

      launchOptions.push("1.12.2")

      if(this.options.overrides.fullscreen)
        launchOptions.push("--fullscreen");

      launchOptions.push("--discordRPC");
      launchOptions.push(this.options.overrides.discordRPC);

      launchOptions.push('--width')
      launchOptions.push(this.options.window.width)
      
      launchOptions.push('--height')
      launchOptions.push(this.options.window.height)

      const launchArguments = args.concat(jvm, classPaths, launchOptions)
      this.emit('arguments', launchArguments)
      this.emit('debug', `[MCLC]: Launching with arguments ${launchArguments.join(' ')}`)

      console.log(launchArguments)
      return this.startMinecraft(launchArguments)
    } catch (e) {
      this.emit('debug', `[MCLC]: Failed to start due to ${e}, closing...`)
      return null
    }
  }

  printVersion () {
    if (fs.existsSync(path.join(__dirname, '..', 'package.json'))) {
      const { version } = require('../package.json')
      this.emit('debug', `[MCLC]: MCLC version ${version}`)
    } else { this.emit('debug', '[MCLC]: Package JSON not found, skipping MCLC version check.') }
  }

  createRootDirectory () {
    if (!fs.existsSync(this.options.root)) {
      this.emit('debug', '[MCLC]: Attempting to create root folder')
      fs.mkdirSync(this.options.root)
    }
  }

  createGameDirectory () {
    if (this.options.overrides.gameDirectory) {
      this.options.overrides.gameDirectory = path.resolve(this.options.overrides.gameDirectory)
      if (!fs.existsSync(this.options.overrides.gameDirectory)) {
        fs.mkdirSync(this.options.overrides.gameDirectory, { recursive: true })
      }
    }
  }

  async extractPackage () {
    if (this.options.clientPackage) {
      this.emit('debug', `[MCLC]: Extracting client package to ${this.options.root}`)
      await this.handler.extractPackage()
    }
  }

  async getModifyJson () {
    let modifyJson = null

    if (this.options.forge) {
      this.options.forge = path.resolve(this.options.forge)
      this.emit('debug', '[MCLC]: Detected Forge in options, getting dependencies')
      modifyJson = await this.handler.getForgedWrapped()
    } else if (this.options.version.custom) {
      this.emit('debug', '[MCLC]: Detected custom in options, setting custom version file')
      modifyJson = modifyJson
    }

    return modifyJson
  }

  startMinecraft (launchArguments) {
    var cmdStart = this.options.javaPath + " " + launchArguments.join(" ");
    const minecraft = child.spawn(this.options.javaPath ? this.options.javaPath : 'java', launchArguments, { cwd: this.options.overrides.cwd || this.options.root, detached: this.options.overrides.detached })
    minecraft.stdout.on('data', (data) => this.emit('data', data.toString('utf-8')))
    minecraft.stderr.on('data', (data) => this.emit('data', data.toString('utf-8')))
    minecraft.on('close', (code) => this.emit('close', code))
    return {minecraft: minecraft, pid: minecraft.pid, cmdStart: cmdStart}
  }
}

module.exports = MCLCore
